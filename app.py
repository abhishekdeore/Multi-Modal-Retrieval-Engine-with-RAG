import streamlit as st
import os
from PIL import Image
import matplotlib.pyplot as plt
import io
import time
import base64
from rag_engine import RAGEngine
import time
from src.text_processor import TextProcessor
from src.image_processor import ImageProcessor
from src.retrieval_engine import MultiModalRetrievalEngine

# Configure page
st.set_page_config(
    page_title="Multi-Modal Search Engine",
    page_icon="üîç",
    layout="wide"
)

# Initialize session state for storing models and engine
if 'initialized' not in st.session_state:
    st.session_state.initialized = False
    st.session_state.text_processor = None
    st.session_state.image_processor = None
    st.session_state.engine = None

if 'rag_initialized' not in st.session_state:
    st.session_state.rag_initialized = False
    st.session_state.rag_engine = None


def rag_interface():
    """
    Provides an interface for initializing and using the Retrieval-Augmented Generation (RAG) system.
    Allows the user to input an API key and initialize the RAG engine. Once initialized,
    the user can ask text-based or image-based questions and receive answers generated by the RAG system.
    """
    # Section header in the Streamlit interface
    st.subheader("Retrieval-Augmented Generation (RAG)")
    
    # Expandable section for API key input and RAG initialization
    with st.expander("Gemini API Key Setup", expanded=not st.session_state.rag_initialized):
        # Secure text input for API key entry
        api_key = st.text_input("Enter your Gemini API Key:", type="password")
        
        # Button to initialize the RAG engine with the entered API key
        if st.button("Initialize RAG"):
            # Check if the API key field is empty
            if not api_key:
                st.error("Please enter an API key.")
            else:
                # Show spinner during the initialization process
                with st.spinner("Initializing RAG engine..."):
                    # Check if the retrieval engine has already been initialized
                    if st.session_state.engine and not st.session_state.rag_initialized:
                        # Create the RAG engine object with the existing retrieval engine
                        st.session_state.rag_engine = RAGEngine(st.session_state.engine)
                        # Attempt to initialize the RAG engine with the API key
                        success = st.session_state.rag_engine.initialize(api_key)
                        
                        # Check if the initialization was successful
                        if success:
                            st.session_state.rag_initialized = True
                            st.success("RAG engine initialized successfully!")
                        else:
                            st.error("Failed to initialize RAG engine. Please check your API key.")
                    else:
                        st.error("Please initialize the retrieval engine first.")
    
    # Section for asking questions using the RAG system
    st.markdown("### Ask Questions About Your Content")
    
    # Define tabs for different types of queries: Text-based and Image-based
    tab1, tab2 = st.tabs(["Text Questions", "Image Questions"])

    # Text Questions Tab
    with tab1:
        st.markdown("### Ask about text content")
        # Input for users to enter their question about the text content
        rag_query = st.text_input("Enter your question about your documents:")
        # Slider to choose how many documents to consider in the response
        n_results = st.slider("Number of documents to consider", 1, 10, 3, key="rag_slider")
        
        # Button to submit the query
        if st.button("Ask", key="rag_ask_btn"):
            # Check if the RAG engine is initialized
            if not st.session_state.rag_initialized:
                st.error("Please initialize the RAG engine first.")
            elif not rag_query:
                st.warning("Please enter a question.")
            else:
                # Placeholder while processing the query
                placeholder = st.empty()
                placeholder.info("Thinking...")
                
                try:
                    # Stream the response to dynamically display the generated content
                    response_stream = st.session_state.rag_engine.answer_query(
                        rag_query, n_results, stream=True
                    )
                    
                    # Empty container to accumulate and display the streaming response
                    response_container = st.empty()
                    full_response = ""
                    
                    # Iterate over each chunk of the streamed response
                    for chunk in response_stream:
                        if hasattr(chunk, 'text') and chunk.text:
                            full_response += chunk.text
                            response_container.markdown(full_response)
                            time.sleep(0.01)  # Introduce a small delay for smoother visualization
                            
                    placeholder.success("Response generated!")
                except Exception as e:
                    st.error(f"Error generating response: {e}")

    # Image Questions Tab
    with tab2:
        st.markdown("### Ask about images")
        # Input for users to enter their question about the image content
        img_rag_query = st.text_input("Enter your question about images in your collection:")
        # Slider to choose how many images to consider in the response
        n_img_results = st.slider("Number of images to consider", 1, 10, 3, key="img_rag_slider")
        
        # Button to submit the image-based query
        if st.button("Ask", key="img_rag_ask_btn"):
            if not st.session_state.rag_initialized:
                st.error("Please initialize the RAG engine first.")
            elif not img_rag_query:
                st.warning("Please enter a question.")
            else:
                # Placeholder while processing the query
                placeholder = st.empty()
                placeholder.info("Thinking...")
                
                try:
                    # Fetch the response and associated images from the RAG engine
                    response, image_results = st.session_state.rag_engine.answer_image_query(
                        img_rag_query, n_img_results, stream=False
                    )
                    
                    # Display the text-based response
                    st.markdown("### Answer:")
                    st.markdown(response)
                    
                    # Display relevant images if available
                    if 'documents' in image_results and image_results['documents'] and len(image_results['documents'][0]) > 0:
                        st.markdown("### Relevant Images:")
                        cols = st.columns(min(3, len(image_results['documents'][0])))
                        
                        # Loop through each image and display it in a column
                        for i, path in enumerate(image_results['documents'][0]):
                            col_idx = i % len(cols)
                            with cols[col_idx]:
                                try:
                                    img = Image.open(path)
                                    st.image(img, caption=f"Image {i+1}", width=200)
                                except Exception as e:
                                    st.error(f"Error displaying image: {e}")
                            
                    placeholder.success("Response generated!")
                except Exception as e:
                    st.error(f"Error generating response: {e}")


def initialize_engine():
    """
    Initializes the text and image processors, sets them up in a retrieval engine, and indexes any existing data.
    
    This function:
    - Initializes the text and image processors with default settings.
    - Encodes a sample text and image to check embedding dimensions.
    - Assigns processors to the retrieval engine.
    - Indexes available text and image data in the specified directories.
    - Updates the session state to reflect that initialization is complete.
    """
    # Display a spinner in the Streamlit interface while the engine is loading
    with st.spinner('Loading models and initializing engine...'):
        # Initialize the text processor and encode a sample text to retrieve embedding dimensions
        text_processor = TextProcessor()
        sample_embedding = text_processor.encode(["Test embedding"])[0]  # Encodes a sample text
        st.write(f"Text embedding dimension: {len(sample_embedding)}")  # Display embedding size in the UI

        # Initialize the image processor and encode a sample image to retrieve embedding dimensions
        image_processor = ImageProcessor()
        sample_img = Image.new('RGB', (224, 224), color='white')  # Create a blank image
        sample_img_embedding = image_processor.encode([sample_img])[0]  # Encodes the sample image
        st.write(f"Image embedding dimension: {len(sample_img_embedding)}")  # Display embedding size in the UI

        # Store processors in the session state for global access
        st.session_state.text_processor = text_processor
        st.session_state.image_processor = image_processor

        # Initialize the retrieval engine and set the text and image processors
        st.session_state.engine = MultiModalRetrievalEngine()
        st.session_state.engine.set_text_processor(st.session_state.text_processor)
        st.session_state.engine.set_image_processor(st.session_state.image_processor)

        # Check for existing text data and index it
        if os.path.exists('data/text') and len(os.listdir('data/text')) > 0:
            text_data = st.session_state.text_processor.process_text_files('data/text')
            st.session_state.engine.index_text_data(text_data)

        # Check for existing image data and index it
        if os.path.exists('data/images') and len(os.listdir('data/images')) > 0:
            image_data = st.session_state.image_processor.process_image_files('data/images')
            st.session_state.engine.index_image_data(image_data)

        # Mark the engine as initialized in the session state
        st.session_state.initialized = True


def display_image_result(path, score, index):
    """
    Displays an image along with metadata such as filename and similarity score.
    
    Args:
    path (str): The file path to the image.
    score (float): The similarity score of the image, reflecting how closely it matches the query.
    index (int): The index of the image in the result set, used for labeling.

    This function creates a layout with two columns: one for the image and one for the metadata.
    It handles exceptions by displaying an error message if the image cannot be loaded.
    """
    try:
        # Open the image file from the specified path
        img = Image.open(path)
        # Create two columns, with the first being wider to emphasize the image
        col1, col2 = st.columns([3, 1])
        with col1:
            # Display the image with a caption indicating its position in the results
            st.image(img, caption=f"Result {index+1}", width=300)
        with col2:
            # Display the filename and similarity score
            st.markdown(f"**Filename:** {os.path.basename(path)}")
            st.markdown(f"**Similarity:** {score:.2f}")
    except Exception as e:
        # If an error occurs (e.g., file not found), display an error message
        st.error(f"Error displaying image {path}: {e}")

def display_text_result(doc, meta, score, index):
    """
    Displays a text document's metadata and a content preview with its similarity score.

    Args:
    doc (str): The text document content.
    meta (dict): Metadata about the document, including filename and path.
    score (float): The similarity score, indicating the relevance of the document to the query.
    index (int): The index of the text result in the result set.

    This function uses an expander to optionally hide or show detailed information about the document.
    """
    with st.expander(f"Result {index+1}: {meta['filename']} (Score: {score:.2f})"):
        # Display the document's filename, path, and similarity score
        st.markdown(f"**Filename:** {meta['filename']}")
        st.markdown(f"**Path:** {meta['path']}")
        st.markdown(f"**Similarity:** {score:.2f}")
        # Provide a preview of the document content, truncating if necessary
        st.markdown("**Content Preview:**")
        st.text(doc[:500] + "..." if len(doc) > 500 else doc)


def upload_files():
    """
    Allows users to upload text and image files which are then saved and optionally indexed.
    
    This function:
    - Provides file uploaders for both text and image files.
    - Saves uploaded files to designated directories on the server.
    - Initiates indexing of these files if the engine is already initialized.
    - Ensures that directories for saving files are created if they do not exist.
    """
    st.subheader("Upload Files")
    
    # Split the interface into two columns for text and image uploads
    col1, col2 = st.columns(2)
    
    # Column for uploading text files
    with col1:
        st.markdown("### Upload Text Files")
        text_files = st.file_uploader("Upload text files", type=["txt"], accept_multiple_files=True)
        
        # Process each uploaded text file
        if text_files:
            # Ensure the directory for storing text files exists
            os.makedirs('data/text', exist_ok=True)
            
            # Save each file to the specified directory
            for file in text_files:
                file_path = os.path.join('data/text', file.name)
                with open(file_path, 'wb') as f:
                    f.write(file.getbuffer())
    
    # Column for uploading image files
    with col2:
        st.markdown("### Upload Images")
        image_files = st.file_uploader("Upload images", type=["jpg", "jpeg", "png"], accept_multiple_files=True)
        
        # Process each uploaded image file
        if image_files:
            # Ensure the directory for storing image files exists
            os.makedirs('data/images', exist_ok=True)
            
            # Save each file to the specified directory
            for file in image_files:
                file_path = os.path.join('data/images', file.name)
                with open(file_path, 'wb') as f:
                    f.write(file.getbuffer())
    
    # Provide a button to initiate indexing of uploaded files
    if st.button("Index Uploaded Files"):
        # Check if the engine has been initialized
        if st.session_state.initialized:
            with st.spinner("Indexing files..."):
                # Index text files if available
                if os.path.exists('data/text') and len(os.listdir('data/text')) > 0:
                    text_data = st.session_state.text_processor.process_text_files('data/text')
                    st.session_state.engine.index_text_data(text_data)
                
                # Index image files if available
                if os.path.exists('data/images') and len(os.listdir('data/images')) > 0:
                    image_data = st.session_state.image_processor.process_image_files('data/images')
                    st.session_state.engine.index_image_data(image_data)
                
            st.success("Files indexed successfully!")
        else:
            st.error("Please initialize the engine first.")


def search_interface():
    """
    Provides an interface with multiple tabs for different search types: Text Search, Text-to-Image Search,
    and Image-to-Image Search. Each tab includes input fields and buttons to execute searches and display results.
    
    Features:
    - Text Search: Allows users to search for text documents based on a query.
    - Text-to-Image Search: Allows users to search for images related to a text query.
    - Image-to-Image Search: Enables searching for similar images based on an uploaded image.
    """
    st.subheader("Search")

    # Create tabs for each search type to organize the interface
    tab1, tab2, tab3 = st.tabs(["Text Search", "Text-to-Image Search", "Image-to-Image Search"])
    
    # Text Search tab
    with tab1:
        st.markdown("### Search for Text Documents")
        # Input field for users to enter their text query
        text_query = st.text_input("Enter your text query")
        # Slider for users to select the number of results they want to display
        n_results = st.slider("Number of results", 1, 10, 5, key="text_slider")
        
        # Button to trigger the search process
        if st.button("Search Texts", key="text_search_btn"):
            # Check if the system has been initialized and ready to perform searches
            if not st.session_state.initialized:
                st.error("Please initialize the engine first.")
            elif not text_query:
                st.warning("Please enter a query.")
            else:
                try:
                    # Search operation with a spinner indicating processing
                    with st.spinner("Searching..."):
                        results = st.session_state.engine.search_text(text_query, n_results)
                    
                    # Check if any results were found and display them
                    if results and 'documents' in results and results['documents'] and len(results['documents'][0]) > 0:
                        st.success(f"Found {len(results['documents'][0])} results")
                        # Iterate through each result and create an expander for detailed view
                        for i in range(len(results['documents'][0])):
                            with st.expander(f"Result {i+1}: {results['metadatas'][0][i]['filename']}"):
                                # Display metadata and a content preview of each document
                                st.markdown(f"**Filename:** {results['metadatas'][0][i]['filename']}")
                                st.markdown(f"**Path:** {results['metadatas'][0][i]['path']}")
                                similarity = 1 - results['distances'][0][i] if 'distances' in results else "N/A"
                                st.markdown(f"**Similarity:** {similarity:.2f}")
                                st.markdown("**Content Preview:**")
                                content = results['documents'][0][i]
                                st.text(content[:500] + "..." if len(content) > 500 else content)
                    else:
                        st.info("No results found.")
                except Exception as e:
                    st.error(f"Error during search: {e}")
                    st.exception(e)

    
    with tab2:
        # Set up the user interface for Text-to-Image Search
        st.markdown("### Search for Images using Text")
        # Input field for users to submit their text query for searching images
        text_for_img_query = st.text_input("Enter your text query for images")
        # Slider to determine how many image results to display
        n_img_results = st.slider("Number of results", 1, 10, 5, key="text_img_slider")
        
        # Button to trigger the search
        if st.button("Search Images by Text", key="text_img_search_btn"):
            # Check if the engine is initialized before performing the search
            if not st.session_state.initialized:
                st.error("Please initialize the engine first.")
            elif not text_for_img_query:
                st.warning("Please enter a query.")
            else:
                try:
                    # Indicate that the search is processing
                    with st.spinner("Searching..."):
                        # Perform the search using the engine
                        results = st.session_state.engine.search_text_for_images(text_for_img_query, n_img_results)
                    
                    # Check and display the search results
                    if results and 'documents' in results and results['documents'] and len(results['documents'][0]) > 0:
                        st.success(f"Found {len(results['documents'][0])} results")
                        
                        # Use columns to display each image result effectively
                        cols = st.columns(min(3, len(results['documents'][0])))
                        
                        # Iterate over each result to display images with metadata
                        for i in range(len(results['documents'][0])):
                            col_idx = i % len(cols)
                            with cols[col_idx]:
                                path = results['documents'][0][i]
                                try:
                                    # Attempt to open and display the image
                                    img = Image.open(path)
                                    st.image(img, caption=f"Result {i+1}", width=200)
                                    # Show the similarity score, if distances are provided
                                    similarity = 1 - results['distances'][0][i] if 'distances' in results else "N/A"
                                    st.markdown(f"**Similarity:** {similarity:.2f}")
                                except Exception as e:
                                    st.error(f"Error displaying image: {e}")
                    else:
                        st.info("No results found.")
                except Exception as e:
                    st.error(f"Error during search: {e}")
                    st.exception(e)

    
    with tab3:
        # User interface for image-to-image search
        st.markdown("### Search for Images using an Image")
        # File uploader allows the user to upload an image to use as the query
        query_img = st.file_uploader("Upload a query image", type=["jpg", "jpeg", "png"])
        # Slider for selecting the number of similar images to retrieve
        n_similar_img = st.slider("Number of results", 1, 10, 5, key="img_img_slider")
        
        # Display the uploaded image as a query preview
        if query_img is not None:
            st.image(query_img, caption="Query Image", width=200)
            
            # Button to trigger the search for similar images
            if st.button("Search Similar Images", key="img_search_btn"):
                # Ensure the system is ready to perform the search
                if not st.session_state.initialized:
                    st.error("Please initialize the engine first.")
                else:
                    try:
                        # Open and convert the uploaded image to RGB
                        img = Image.open(query_img).convert('RGB')
                        
                        # Perform the search and indicate processing with a spinner
                        with st.spinner("Searching..."):
                            results = st.session_state.engine.search_image(img, n_similar_img)
                        
                        # Check if the search returned any results
                        if results and 'documents' in results and results['documents'] and len(results['documents'][0]) > 0:
                            st.success(f"Found {len(results['documents'][0])} results")
                            
                            # Display images in columns for better layout
                            cols = st.columns(min(3, len(results['documents'][0])))
                            
                            # Loop through each result and display the image along with similarity score
                            for i in range(len(results['documents'][0])):
                                col_idx = i % len(cols)
                                with cols[col_idx]:
                                    path = results['documents'][0][i]
                                    try:
                                        # Attempt to open and display each result image
                                        img = Image.open(path)
                                        st.image(img, caption=f"Result {i+1}", width=200)
                                        similarity = 1 - results['distances'][0][i] if 'distances' in results else "N/A"
                                        st.markdown(f"**Similarity:** {similarity:.2f}")
                                    except Exception as e:
                                        st.error(f"Error displaying image: {e}")
                        else:
                            st.info("No results found.")
                    except Exception as e:
                        st.error(f"Error during search: {e}")
                        st.exception(e)



def main():
    st.title("üîç Multi-Modal Retrieval Engine with RAG")
    st.markdown("""
    This application allows you to:
    - Search across different modalities (text, images)
    - Upload and index your own files
    - Ask questions and get intelligent answers about your content
    """)
    
    # Initialize engine button
    if not st.session_state.initialized:
        if st.button("Initialize Engine"):
            initialize_engine()
            st.success("Engine initialized successfully!")
    else:
        st.success("Engine is initialized and ready to use.")
    
    # Interface sections
    upload_files()
    st.markdown("---")
    search_interface()
    st.markdown("---")
    rag_interface()  # Add this line to include the RAG interface

if __name__ == "__main__":
    main()